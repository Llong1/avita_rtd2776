#include "UserCommonInclude.h"
#include "spi_secure.h"
#include <stdio.h>                /* prototype declarations for I/O functions */
//#include <string.h>
//#include <stdlib.h>
#include "w74m00av.h"



/* public array use for RPMC algorithm */
uint8_t message[16]={0};	// Message data use for insturction input
uint8_t counter[4]={0};	// counter data (32bit)
uint8_t tag[12]={0};		// Tag data use for increase counter
uint8_t signature[32]={0};	// Signature data use for every instruction output

uint8_t HMACKey[32]={0};	// HMACkey array

uint8_t Input_tag[12]={0};	// Input tag data for request conte

static void delay(uint8_t msec)
{
 // val = 1;
 // Delay5us(val);	


  int i;
  char j;

  for(i = 0; i < msec; i++)
   for(j = 0; j < 82; j++)
   _nop_ ();   

}
static void write_MOSI(uint8_t byte_out)
{
	byte_out =0;
	
}
static uint8_t read_MISO()
{
	uint8_t byte_in = 0;
	
	return byte_in;
}

static void write_SCLK(uint8_t byte_out)
{
	byte_out= 0;
	
	
	//return byte_out;
	
}


uint8_t W74M_Write_Read_Byte(uint8_t byte_out)
{
	//SPI_Write_Read_Byte(Write_data);
	uint8_t byte_in = 0;
    uint8_t bitv;

    for (bitv = 0x80; bitv; bitv >>= 1) 
	{
      /* Shift-out a bit to the MOSI line */
        write_MOSI((byte_out & bitv) ? _HIGH : _LOW);

        /* Delay for at least the peer's setup time */
        //delay(SPI_SCLK_LOW_TIME);

        /* Pull the clock line high */
        write_SCLK(_HIGH);

        /* Shift-in a bit from the MISO line */
        if (read_MISO() == _HIGH)
            byte_in |= bitv;

        /* Delay for at least the peer's hold time */
        //delay(SPI_SCLK_HIGH_TIME);

        /* Pull the clock line low */
        write_SCLK(_LOW);

    }

    return byte_in;
}

/********************************************************************************************
Function: Read counter
Argument:
return:	counter number
date: 2015/8/12
********************************************************************************************/
//unsigned int WB_RPMC_ReadCounterData(void){
//  return (((((counter[0]*0x100)+counter[1])*0x100)+counter[2])*0x100)+counter[3];
//}


/********************************************************************************************
Function: RPMC read RPMC status
Argument: checkall

	checkall = 0: only read out RPMC status
	checkall = 1: Read out counter data, tag, signature information
	
return: RPMC status 
date: 2015/8/12
********************************************************************************************/
uint8_t WB_RPMC_ReadRPMCstatus(uint8_t checkall)
{
  uint8_t i;
  uint8_t RPMCstatus;

  W74M_CS_OUT_LOW; // chip enable
  W74M_Write_Read_Byte(0x96);		// read RPMC status command
  W74M_Write_Read_Byte(0x00);
  RPMCstatus = W74M_Write_Read_Byte(0x00);		// status was readout, read RPMC status don't need signature input
  if(checkall ==0)  
  {
    W74M_CS_OUT_HIGH;
  }
  else
  {							// After signature matched reqeust counter instruction, counter data can readout as follow.
    for(i=0;i<12;i++){
    tag[i]=W74M_Write_Read_Byte(0x00);			// tag information repeat
    }
    for(i=0;i<4;i++){
    counter[i] = W74M_Write_Read_Byte(0x00);	// counter data readout
    }
    for(i=0;i<32;i++){
    signature[i]=W74M_Write_Read_Byte(0x00);	// signature repeat
    }
    W74M_CS_OUT_HIGH;
  }//end else
  
  return RPMCstatus;
}




/********************************************************************************************
Function: RPMC request counter data
Argument: 
	cadr: selected Counter address, from 1~4
	hmackey: 32 byte HMACKEY which is generated by WB_RPMC_UpHMACkey()
	input_tag: 12 byte input Tag data, which can be time stamp, serial number or random number. 
	these data would repeat after success WB_RPMC_ReqCounter() operation
return: 
date: 2015/8/12
********************************************************************************************/
void WB_RPMC_ReqCounter(uint8_t cadr, uint8_t *hmackey,uint8_t *input_tag)
{
  uint8_t i;
  
  message[0]=0x9B;
  message[1]=0x03;
  message[2]=cadr-1;
  message[3]=0x00;
  
  for(i=0;i<12;i++)
  {
    message[i+4]=*(input_tag+i);
  }
  
  hmacsha256(hmackey,32,message,16,signature);  // caculate signature by SHA256

  W74M_CS_OUT_LOW;
  for(i=0;i<16;i++){
    W74M_Write_Read_Byte(message[i]);
  }
  for(i=0;i<32;i++){
    W74M_Write_Read_Byte(signature[i]);
  }
  W74M_CS_OUT_HIGH;
  return;
}


/********************************************************************************************
Function: RPMC write rootkey
Argument: 
	cadr: selected Counter address, from 1~4
	rootkey: 32 byte rootkey infomration.
return: RPMC status
date: 2015/8/12
********************************************************************************************/
#if 1
uint8_t WB_RPMC_WrRootKey(uint8_t cadr,uint8_t *rootkey)
{
  uint8_t i;
  uint8_t failCnt = 200;
  memset(message, 0x00, sizeof(message[0])*8);
  message[0]=0x9B;
  message[1]=0x00;
  message[2]=cadr-1;// counter address 0~3,so -1
  message[3]=0x00; 
  
  hmacsha256(rootkey,32,message,4,signature);	// caculate signature by SHA256
 
  W74M_CS_OUT_LOW;
  W74M_Write_Read_Byte(message[0]);
  W74M_Write_Read_Byte(message[1]);
  W74M_Write_Read_Byte(message[2]);
  W74M_Write_Read_Byte(message[3]);
  for(i=0;i<32;i++){
    W74M_Write_Read_Byte(*(rootkey+i));
  }
  for(i=0;i<28;i++){
    W74M_Write_Read_Byte(signature[i+4]);
  }
  W74M_CS_OUT_HIGH;

/*
	DebugMessageUser("write root ", 0);
    for(i=0;i<32;i++){
    DebugMessageUser("rootkey ", *(rootkey+i));
  }
  for(i=0;i<28;i++){
    SPIin(signature[i+4]);
    DebugMessageUser("signature ", signature[i+4]);
  }
  */
 // delay(30);
  
  while((WB_RPMC_ReadRPMCstatus(0)&0x01==0x01)&&failCnt)
  {
	// wait until RPMC operation done
		--failCnt;
    delay(30);

  }  
  
  i = WB_RPMC_ReadRPMCstatus(0);
  return i;
  //return WB_RPMC_ReadRPMCstatus(0);  
}
#endif


/********************************************************************************************
Function: RPMC Update HMAC key, this function should call in every Gneiss power on
Argument: 
	cadr: selected Counter address, from 1~4
	rootkey: rootkey use for generate HMAC key
	hmac4: 4 byte input hmac message data, which can be time stamp, serial number or random number. 
	hmackey: 32 byte HMACKEY, which would be use for increase/request counter after WB_RPMC_UpHMACkey() operation success
return: 
date: 2015/8/12
********************************************************************************************/
uint8_t WB_RPMC_UpHMACkey(uint8_t cadr,uint8_t *rootkey,uint8_t *hmac4,uint8_t *hmackey)
{
  uint8_t i;
  uint8_t failCnt = 200;
  message[0]=0x9B;
  message[1]=0x01;
  message[2]=cadr - 1;
  message[3]=0x00;
  message[4]=*(hmac4+0);
  message[5]=*(hmac4+1);
  message[6]=*(hmac4+2);
  message[7]=*(hmac4+3);
  
  hmacsha256(rootkey,32,hmac4,4,hmackey);	// use rootkey generate HMAC key by SHA256  
  hmacsha256(hmackey,32,message,8,signature);	// caculate signature by SHA256
  
  W74M_CS_OUT_LOW;
  for(i=0;i<8;i++){
  W74M_Write_Read_Byte(message[i]);
  }
  for(i=0;i<32;i++){
  W74M_Write_Read_Byte(signature[i]);
  }
  W74M_CS_OUT_HIGH;
/*
  DebugMessageUser("up HMAC KEY", 0);
  for(i=0;i<8;i++){
  //SPIin(message[i]);
  DebugMessageUser("msg", message[i]);
  }
  for(i=0;i<32;i++){
  //SPIin(signature[i]);
  DebugMessageUser("msg", signature[i]);
  }
*/
  //delay(30);

  while((WB_RPMC_ReadRPMCstatus(0)&0x01==0x01)&&failCnt)
  {
	// wait until RPMC operation done
	--failCnt;
    delay(30);

  } 

  i = WB_RPMC_ReadRPMCstatus(0);
  return i;
 // return WB_RPMC_ReadRPMCstatus(0); 
}



/********************************************************************************************
Function: RPMC request counter data
Argument: 
	cadr: selected Counter address, from 1~4
	hmackey: 32 byte HMACKEY which is generated by WB_RPMC_UpHMACkey()
	input_tag: 12 byte input Tag data, which can be time stamp, serial number or random number. 
	these data would repeat after success WB_RPMC_ReqCounter() operation
return: 
date: 2015/8/12
********************************************************************************************/
uint8_t WB_RPMC_IncCounter(uint8_t cadr,uint8_t *hmackey,uint8_t *input_tag)
{
  uint8_t i;
  uint8_t failCnt = 200;
  WB_RPMC_ReqCounter(cadr, hmackey, input_tag);
  
  delay(100);  

  i = WB_RPMC_ReadRPMCstatus(1);	// Get counter information

 // i = WB_RPMC_ReadRPMCstatus(1);	// Get counter information
  
  message[0]=0x9B;
  message[1]=0x02;
  message[2]=cadr-1;
  message[3]=0x00;
  for(i=0;i<4;i++){
  message[i+4]=counter[i];
  }  
  
  hmacsha256(hmackey,32,message,8,signature);	// caculate signature by SHA256
  
  W74M_CS_OUT_LOW;
  for(i=0;i<8;i++){
  W74M_Write_Read_Byte(message[i]);
  }
  for(i=0;i<32;i++){
  W74M_Write_Read_Byte(signature[i]);
  }
  W74M_CS_OUT_HIGH;
  
  //DebugMessageUser("Inc Counter", 0);
  //for(i=0;i<8;i++){
  //DebugMessageUser("message", message[i]);
  //}
  //for(i=0;i<32;i++){
  //DebugMessageUser("signature", signature[i]);
  //}

  
  //delay(30);


  while((WB_RPMC_ReadRPMCstatus(0)&0x01==0x01)&&failCnt){
	// wait until RPMC operation done
	--failCnt;
	
    delay(30);

  }  
  
  i = WB_RPMC_ReadRPMCstatus(0);
  return i;
//  return WB_RPMC_ReadRPMCstatus(0); 
}



/********************************************************************************************
Function: RPMC Challenge signature. Main security operation
Argument: 
	cadr: selected Counter address, from 1~4
	hmackey: 32 byte HMACKEY which is generated by WB_RPMC_UpHMACkey()
	input_tag: 12 byte input Tag data, which can be time stamp, serial number or random number.
return: 
	Challlenge result. if signature match, return 0.
date: 2015/12/09
********************************************************************************************/
uint8_t WB_RPMC_Challenge(uint8_t cadr, uint8_t *hmackey,uint8_t *input_tag)
{
	uint8_t Verify_signature[32];	// signature for verification. should match signature[32]
	uint8_t i;
	WB_RPMC_ReqCounter(cadr, hmackey, input_tag);
	
    delay(100); 

	WB_RPMC_ReadRPMCstatus(1);	// Get counter information. In this stage, tag[12], counter[4], signature[32] is updated.

//    WB_RPMC_ReadRPMCstatus(1);

	// Comment: the message using for signature is tag[0:11]+count[0:3] data, you can also use memcpy to casecade these data
	/*
	memcpy(message, tag, 12);
	memcpy(message+12, counter, 4);
	*/	
	for(i = 0; i < 12; i++){
		message[i] = tag[i];	// message [0:11] = tag[0:11]
	}
	for(i = 0; i < 4; i++){
		message[12+i] = counter[i];	// message [12:15] = counter[0:3]
	}
	hmacsha256(hmackey,32,message,16,Verify_signature);	// Verification signature should as same as security output
	return memcmp(Verify_signature, signature, 32);		// Compare Verification signature (computed by controllor) and internal signature (return from security Flash by request counter operation)
}



/********************************************************************************************
  * @file    /WB_Gneiss_Sample_Code_APP.c
  * @author  Winbond FAE Steam Lin
  * @version V1.1.0
  * @date    09-December-2015
  * @brief   This code provide the Demo code for RPMC operation. Please do not copy the rootkey generate method directly.
		     Rootkey generate method should be keep in secret and should not exposed.		 
			 
  *            
  * COPYRIGHT 2015 Winbond Electronics Corporation.
********************************************************************************************/
#if 0
uint8_t RPMC_Write_RootKey(uint8_t cadr,uint8_t *Root_key)
{
	uint8_t Result = RESULT_ERR;
	
	//  unsigned char Check_tag[12];	// Output tag data for verification
	//  unsigned char Check_signature[32]; // Output signature
 	uint8_t RPMCStatus;
	//  unsigned int RPMC_counter;
	//  unsigned long cnt;
  	/* first stage, initial rootkey, please not use Winbond's rootkey generate rule method directly */
  	/* rootkey information can up to 32byte (256bit)	*/ 

	#if 1	   // initial Rootkey, use first rootkey/counter pair
  	RPMCStatus = WB_RPMC_WrRootKey(cadr, Root_key);        // initial Rootkey, use first rootkey/counter pair
  	if(RPMCStatus == 0x80)
  	{
    	// Write rootkey success
    	Result = RESULT_OK;
		printf("== WrRootKey success== \r\n");
  	}
  	else
  	{
    	// write rootkey fail, check datasheet for the error bit
		printf("== WrRootKey Fail ==\r\n");
	}
	return Result;
    #endif
  	

}
#endif
#if 1
uint8_t secure_boot(uint8_t RootKey_location)    
{
	uint8_t RPMCStatus;
	
	uint8_t ROOTKey[32];	// Rootkey array
	
	uint8_t HMACMessage[4]; // HMAC message data, use for update HMAC key
	
	/* Second stage, update HMACKey after ever power on. without update HMACkey, Gneiss would not function*/
	HMACMessage[0] = 0xA4; //rand()%0x100;        // Get random data for HMAC message, it can also be serial number, RTC information and so on.
	HMACMessage[1] = 0xA3; //rand()%0x100;
	HMACMessage[2] = 0xA2; //rand()%0x100;
	HMACMessage[3] = 0xA1; //rand()%0x100;


  /* first stage, initial rootkey, please not use Winbond's rootkey generate rule method directly */
  /* rootkey information can up to 32byte (256bit)	*/ 
  ROOTKey[0] = 'W';
  ROOTKey[1] = 'I';
  ROOTKey[2] = 'N';
  ROOTKey[3] = 'B';
  ROOTKey[4] = 'O';
  ROOTKey[5] = 'N';
  ROOTKey[6] = 'D';
  
	/* Update HMAC key and get new HMACKey. 
	HMACKey is generated by SW using Rootkey and HMACMessage.
	RPMC would also generate the same HMACKey by HW   */
	RPMCStatus = WB_RPMC_UpHMACkey(RootKey_location, ROOTKey, HMACMessage, HMACKey); 
	if(RPMCStatus == 0x80)
	{
		// update HMACkey success
		printf("== UpHMACKey Success== \r\n");
	}
	else
	{
		// write HMACkey fail, check datasheet for the error bit
		printf("== UpHMACKey Fail== \r\n");
	}
	/* update HMACKey operation done     */
	/* Third stage, increase RPMC counter */  
	/* input tag is send in to RPMC, it could be time stamp, serial number and so on*/
	Input_tag[0] = '2';
	Input_tag[1] = '0';
	Input_tag[2] = '1';
	Input_tag[3] = '5';
	Input_tag[4] = '1';
	Input_tag[5] = '1';
	Input_tag[6] = '1';
	Input_tag[7] = '1';
	Input_tag[8] = '2';
	Input_tag[9] = '4';
	Input_tag[10] = '4';
	Input_tag[11] = '4';
	
	RPMCStatus = WB_RPMC_IncCounter(RootKey_location, HMACKey, Input_tag);
  	if(RPMCStatus == 0x80)
  	{
   		// increase counter success
   		printf("== IncCounter success== \r\n");
 	}
  	else
  	{
    	// increase counter fail, check datasheet for the error bit
    	printf("== IncCounter Fail== \r\n");
	}
  	/* counter data in stoage in public array counter[], data is available if WB_RPMC_IncCounter() operation successed */
	//  RPMC_counter = WB_RPMC_ReadCounterData();
  	/* increase RPMC counter done*/

 	/* Main security operation call challenge*/
 	// while(1){
	if(WB_RPMC_Challenge(RootKey_location, HMACKey, Input_tag)!=0) 
	{
		/* return signature miss-match */
		return RESULT_ERR;
	}
	//  }
  	return 	RESULT_OK;
	
}
#endif

